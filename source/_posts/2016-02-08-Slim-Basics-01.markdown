---
layout: post
title: Slim Basics 01
date: 2016-02-08 04:29:10 +0100
comments: true
sharing: true
published: true 
categories: [AntiPatterns, Ruby, Rails, Templating, Slim]
---

Titles

Boss-level Ruby templates with Slim

Deluxe templating with Slim

{% img /images/Slim/slim-fishbowl-refined.png %}

## Topics

+ Why Slim?
+ What are Templates?
+ What about ERB & Haml?
+ Getting Started
+ Syntax
+ Line Indicators
+ HTML Tags
+ Helpers
+ Safety
+ Logic-less Mode
+ Performance
+ Framework Support
+ Temple & Tilt
+ Rails
+ Sinatra

## Why Slim?

If you have given Haml a shot before, you’ll probably already know a couple of the arguments I’m gonna make. I think it’s nevertheless a good idea to follow along because you might have already decided to use a more minimalistic templating engine and I’d like you to see the advantages Slim offers as well.

Before we dive into why Slim is cool, I wanna answer real quick what Slim actually is and what it does for you. The documentation sums this up quite nicely: “Slim is a fast, lightweight templating engine with support for Rails 3 and 4”. You can also be use it with Sinatra and even plain Rack. So, if you are a bit tired of using ERB for writing your templates or you are not super satisfied with what Haml has to offer, then you are barking up exactly the right tree with Slim. In terms of syntax used, the people behind Slim were trying to find an answer to the following question: “What's the minimum required to make this work?” For writing the minimal amount of front-end code possible, this sure sounds like the right question to ask imho. Does Slim offer a perfect solution to all your templating concerns? Probably not, but quite frankly, it might just offer the best! Is easy to learn? I think so, but it’s hard to know what other people consider easy. I’d say this though,it takes a bit to get used to but it’s definitely no rocket science. So no need to feel intimidated if you are a bit new to the coding side of things. Will you have a good time with it? Absolutely! 

So, why Slim? The answer is quite straightforward I think. Your markup should be as beautiful as possible! You should have a good time working with it and the less time you need to spend wading through tons of tag matter the better. What is beautiful you might ask? Of course ,that is not an answer I’ll try to tackle, but being minimal in that regard rarely hurts. What about becoming super cryptic because the templating engine tries to be super smart in being minimal? That is a fair concern and I hope you will be happy to hear that the team behind Slim takes this very seriously. They want to remove as much as possible from plain old HTML and reveal only the essential parts—all without becoming too cryptic. They core team tries to go even a step beyond that, they are really concerned about the aesthetics of Slim code. Pretty good deal, don’t you think? 

Isn’t it much nicer if you can just glance at a template and be able to easily digest what’s going on? Templates can become a very ‘crowded’ place—even if you make intelligent use of partials—and as a consequence, you want to reduce the amount of noise to the absolute minimum. Have you maybe tried the indented Sass (.sass) syntax? I hope you did, it’s just awesome! If so, you probably will have a similar appreciation for what Slim has to offer. It’s also whitespace sensitive which lead to really succinct and readable code. Let’s take this piece of HTML / ERB code and compare it to Slim.

``` html

<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
    <%= csrf_meta_tags %>
  </head>
  <body>
    <header class="navbar">
      <div class="logo">
        <%= link_to "sample app", 'root_path', id: "logo" %>
        <nav>
          <ul class="navbar-right">
            <li><%= link_to "Home",   'root_path' %></li>
            <li><%= link_to "Help",   'help_path' %></li>
            <li><%= link_to "Log in", 'login_path' %></li>
          </ul>
        </nav>
      </div>
    </header>
    <div class="main">
      <%= yield %>
    </div>
  </body>
</html>

```

Let’s compare this with a Slim version.

``` slim

doctype html
html
  head
    title
      = full_title(yield(:title))
    = stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true
    = javascript_include_tag 'application', 'data-turbolinks-track' => true
    = csrf_meta_tags
  body
    header.navbar
      .logo
        = link_to "sample app", 'root_path', id: "logo"
        nav
          ul.navbar-right
            li
              = link_to "Home",   'root_path'
            li
              = link_to "Help",   'help_path'
            li
              = link_to "Log in", 'login_path'
    .main
      = yield

```

Sure, you are not used to the syntax yet so it might look a bit alien at first but I’m sure you can appreciate how succinct it reads. No left / right angle brackets, no need to write divs—instead we can focus on the name their ids and classes have—it feels a lot less messy and more organized, don’t you think?

For comparison, here is the Haml version. It’s really not meant as an opportunity to bash Haml, it just shows you how similar it is but also that Slim goes a step further with its choice of minimal syntax and the result is even more elegant I think. Why go so minimal and still make me type the ```%``` sign all the time. My index finger has better things to do than grabbing shift-5 all the time. Can you customize that behaviour? Pretty sure, at least I hope so! But the design seems a bit flawed and less spartan compared to Slim. I realize that this is a matter of taste though, so I’ll leave it at that.

``` haml

!!!
%html
  %head
    %title= full_title(yield(:title))
    = stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true
    = javascript_include_tag 'application', 'data-turbolinks-track' => true
    = csrf_meta_tags
  %body
    %header.navbar
      .logo
        = link_to "sample app", 'root_path', id: "logo"
        %nav
          %ul.navbar-right
            %li= link_to "Home",   'root_path'
            %li= link_to "Help",   'help_path'
            %li= link_to "Log in", 'login_path'
    .main
      = yield

```


+ It’s speedy.
+ Super readable.
+ Index finger friendly.
+ It has a smart syntax.
+ Its aesthetic is minimal.
+ It is highly configurable
+ It’s boss-level templating.
+ It’s fun to write and looks dope.
+ Automatic HTML escaping by default
+ Super nice Rails and Sinatra integration
+ Very minimal templates that are easy to maintain.
+ Is extensive and allows you to write plugins and extensions.
+ There is a logic-less mode for times when you want to output HTML but have no reason to include Ruby code.
+ It has configurable shortcuts for tags—which is a pretty nice feature to customize the engine to your needs.
+ And finally because Slim’s syntax is guided by one very cool motto: “What's the minimum required to make this work”. This is very hard not to like.

## What Are Templates?

In terms of programming experience, if you consider yourself to be more on the newbie side of things, I’ll try to give you a quick round trip before we start using Slim. When people talk about templates, they mostly mean plain HTML markup with dynamic code that is often used for flow control, object injection or partial template (partials) rendering. For example when a controller provides you with instance variables that can be used by the view via (instance)variable substitution to display attributes from that object. All this happens via the template processor of your choice—ERB, Haml, Slim and the likes—which combines all your web templates into a final web page. Templates can also be used to generate XML and RSS feeds as well as other forms of structured text files.

You can define various “layouts” that are handling particular parts of your website and the data that needs to be displayed systematically and with the smallest amount of repetition. When you started playing with Rails, you surely have been using ERB for exactly these kinds of scenarios. ERB takes the plain text portions and hands them to the final document and only processes code that is marked as such. I’m not going into details how ERB works and suppose you have a basic familiarity before you dive into Slim. I would not recommend to use Slim if you are not already familiar with Rails’ default way of templating since you will have a much easier time to play with Slim understanding how templating works out of the box in Rails. 

Below is a basic ERB example of a template that displays a collection of missions that are associated with an ```@agent``` object. Directly below, it also uses a method from a Ruby Gem to paginate the ```@missions``` collection.

``` erb

<% if @agent.missions.any? %>
  <h4>Missions (<%= @agent.missions.count %>)</h4>
  <ul class="missions">
    <%= render @missions %>
  </ul>
  <%= will_paginate @missions %>
<% end %>

```

This is a small section of a template that shows nicely that it’s nothing more than a static HTML part that has some dynamic injections from some Ruby code. If we wouldn’t use templates like this, we’d have to manually write code for every new object that we want to see displayed on a page. Not sure about you, but I can’t imagine a bigger nightmare or waste of time than that. Templates give us a handy tool for making our view layer smart and dynamic without repeating ourselves. As you can also see from this example, templates let us use partial templates that we can render where needed. Here we have a ```_mission.html.erb``` partial somewhere which helps us to iterate over a collection of ```@mission``` objects which in turn get listed inside our ```.missions``` class.

As you can see, templates are nothing magic but are super handy to make developing web apps a lot more efficient and organized. I just wanted to make sure that we are all on the same page before diving into Slim.

## What about ERB & Haml?

If you like using these tools, it’s perfectly fine. Nothing wrong with that. The thing is, if you are looking for something smarter that is more minimalistic, it’s hard to find something that goes further than Slim.

## Getting Started

## Syntax

## Line Indicators
