---
layout: post
title: Rake Basics 03
date: 2016-03-27 04:29:10 +0100
comments: true
sharing: true
published: true 
categories: [Rake, Ruby, Ruby on Rails, Make]
---

{% img /images/Rake/Victory-Garden-cropped.jpg 500 %}

## Topics

+ Passing Arguments
+ Pathmap
+ FileList
+ Clean
+ Clobber

## Passing Arguments

You have two options to pass arguments to Rake tasks. One by using Bash variables or by making use of Rake’s syntax itself.

### ENV Variable

In case you haven’t played with Bash before—or Bash sounds like gobbledegook to you—let’s take five and start from the beginning. Bash in your shell offers two sorts of variables, global aka environment variables and local ones. Both are written in uppercase. The environment variables are global ones, which means they are available in all shells and not vanish when you close one—unlike local Bash variables which are only available in the current shell. Environment variables can contain data that can be used by multiple applications and are often used as a handy way to share configuration settings. In contrast to that, local Bash variables are just that, local. In our context of using Rake, you have the ability to access both via Ruby and in effect pass variables from the command line.

### FYI

Just as a little aside, if you type `env` or `ENV` in your shell, you’ll get access to a whole bunch of environment variables. I redacted the list, but for a better understanding of what environment variables are and what they include, I encourage you to run it for yourselves.

###### Shell

``` bash

env

```

###### Output

``` bash

TERM_PROGRAM=Apple_Terminal
TERM=screen-256color
SHELL=/bin/bash
TMUX=/private/var/folders/4z/3np9k5ks62b1xpbn_w_lmrgh0000gr/T/tmux-504/default,4146,0
EDITOR=vim
LANG=en_US.UTF-8
TMUX_PANE=%1
is_vim=echo "#{pane_current_command}" | grep -iqE "(^|\/)g?(view|n?vim?x?)(diff)?$"
...
...
...

```

If you want to see a list of local Bash variables you can run `set`.

###### Shell

``` bash

( set -o posix ; set ) | less

```

The `set` command gives you a lot more output but the above shows you the relevant bits right away.

### Ruby’s ENV Class Method

Ruby offers a way to use environment and local Bash variables alike via a hash-like accessor. For our needs, when we pass a variable to a Rake task, it’s gonna be a local Bash variable which you can find in the list of variables running `set` or a variation of it. Ruby can read it out using `ENV['VARIABLE']`.

###### Shell

``` bash

rake prepare_book BOOKTITLE='Confessions of a unicorn'

```

What I want to make clear though is that this variable won’t get added to the ENV list that your system uses—the stuff that you saw calling `env` from the shell. To add it to that list, you would need to `export` it. This is another [story](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html), but I thought I should make this clear.


###### Some Rakefile

``` ruby

task :prepare_book do
  book_title = ENV['BOOKTITLE'] || 'Working Title'
  puts "Do something with the #{book_title}"
end

```

In this task definition you can see how we prepared to accept or incorporate the variable passed to the task invocation. Ruby’s `ENV[BASHVARIABLE]` does all the heavy lifting. If `BOOKTITLE` would have been a global environment variable though, we could have accessed it inside this task definition as well with this syntax.

### Rake Parameter Syntax

The second approach is using pure Rake syntax. You simply pass variables into square braces. That approach is better and you can keep things more isolated. Why involve Bash if Rake is perfectly capable of handling this? Plus you don’t have any Bash variables floating around that way. If you want to pass multiple arguments into a task, it’s a lot more elegant as well.

###### Shell

``` bash

rake "create_mi6_agent[James, Bond, 007]"

```

###### Some Rakefile

``` ruby

task :create_mi6_agent, [:first_name, :last_name, :number] do |t, args|
  puts "Number #{args.number} is commander #{args.first_name} #{args.last_name}."
end

```

When you pass in more arguments than you have defined in your task, you can simply access them via `args`. `args.extras` displays an array of all the additionally passed in parameters. ```args.to_a``` shows you all the parameters—in an array as well of course.

## FileList

In previous examples we have been collecting lists of files that need some transformation. That’s tedious, right? FileList is one of those niceties that makes Rake a powerful tool. It’s just too easy to define a glob pattern for the files you need and have it automatically be up to date when you add or delete files from that destination. With that at our disposal, filtering lists can be as straightforward or as sophisticated as we need. Regular expressions are just the tip of the iceberg—although very handy of course. And let’s not forget that Rake has an eye on the timestamp of our files and filters out files that don’t need to be involved when they are up to date.

###### Some Rakefile

``` ruby

image_list = FileList['images/*.png']

=> ["images/jim-weirich.png", "images/zen-rake.png"]

```

Managing these files by hand is one sure way to build on sand. And of course, Rake checks the timestamps of this list as well and rebuilds only files that are out of date. A FileList is lazy as well. It doesn’t grab files until you need them. If you have a bunch of file lists, they behave very sane and smart because of that. The lists that don’t get actively used are taking it easy without hitting the file system. It’s more efficient that way.


As you can see below, you can provide multiple glob patterns for the list as well.

###### Some Rakefile

``` ruby

image_list = FileList['images/*.png', 'images/*.jpg']

=> ["images/happy-jim.jpg", "images/jim-weirich.png", "images/zen-rake.png"]

```

Needing lists of files to process is very common for build tools and making it easy or elegant to deal with them is one of the strengths of Rake. FileList makes your Rakefile smaller, smarter and capable of handling an arbitrary number of files that you don’t need to manage. You can leave Rake in charge. So what is a FileList exactly?  Think of it as an array of files that match the given pattern and is finding a bunch of files for you to iterate over and to apply transformations. It’s a specialized Ruby Array this is focused on processing lists of files—storing them as strings.

With large sets of files, exclusions are very neat and useful. For example, if we want to filter out temporary files, backup files from editors, Git files, or certain directories that are unneeded. In short, exclusion rules are for files that you don’t want in your build.

``` ruby

articles = Rake::FileList.new('_posts/**/*.{markdown, md}') do |files|
  files.exclude('/_posts/drafts/*.{markdown, md}')
end

=> ["_posts/published/2016/2016-02-02-some-article.md", "_posts/published/2015/2015-12-12-another-article.markdown"] 
```

We can pass the files of the FileList along via its initializer which accepts a list of file masks which are processes any exclusions within the block. We can simplify the list of file extensions via `{markdown, md}` to keep things DRY. Also, you can chain these exclusions as much as you need to. Here we could even conveniently check if the files included in the FileList are empty (`zero?`) and exclude these from the array that way.

``` ruby

articles = Rake::FileList.new('_posts/**/*.md') do |files|
  files.exclude('/_posts/drafts/*.{markdown, md}')
  files.exclude('_posts/~*')
  files.exclude do |file|
    File.zero?(file)
  end
end

```

We are basically providing multiple glob patterns for collecting only files we need into the FileList. For whatever reason, you can also go the opposite way and include files into a FileList.

``` ruby

FL = FileList['images/*.png']
FL.include('images/private/*.jpg)

```

## Pathmap

Secrete weapon of Rake, shows its true power by enabling you to manipulate file paths

Let’s change some simple extensions. 
~~~
```
"/projects/worldDominationSecrets.xml".ext("html")
# => '/projects/worldDominationSecrets.html'
```
~~~

This is just scratching the surface though. `pathmap` has lots of useful markers that let you be more creative.

Here’s a list:

+ `%d`

+ `%p` -- The complete path.

+ `%f` -- The base file name of the path, with its file extension, but without any directories.

+ `%n` -- The file name of the path without its file extension.

+ `%d` -- The directory list of the path.

+ `%x` -- The file extension of the path. An empty string if there is no extension.

+ `%X` -- Everything but the file extension.

+ `%s` -- The alternate file separator if defined, otherwise use the standard file separator.

+ `%%` -- A percent sign.


require 'rake/clean' library gives you access to two tasks



One method that tackles all the various tasks that having to do with mapping one list of files to a different list of files

makes it easy to translate between lists. Tweaks entries to your needs. as if they existed with a differnt directory or with different file extension

pass it a block for modifying files



Is a FileList methods that applies strings to list of filenames.

``` ruby

IMAGES = FileList['images/*.png']
THUMBS = IMAGES.pathmap('thumbs/%n-thumbs%x')

```

works on list of files

~~~powertool for munging file names


Multiple FileList arrays and .zip them together and iterate over them

``` ruby

.pathmap("%{^images, thumbs}d ...


```

simple substituation command
every directory that begins with images should be replaced with thumbs


## CLEAN & CLOBBER

require 'rake/clean' library gives you access to two tasks

FileList is not only handy for prepping files that are to be transformed. They make it also easy to collect files that you want to have cleaned after you are done with your tasks. CLEAN and CLOBBER are actually FileLists as well—they just have two very specific jobs to handle.

These two tasks are dumb of course and you need to feed them file lists via `include` that you want to disappear.

~~~
require 'rake/clean'
CLEAN.include('*.tmp')
CLOBBER.include('*.tmp', 'build/*')
~~~

Clobber removes everything in the clean list and the clobber list

Not putting everything in a clean task is handy because you can differentiate what you want to keep around more elegantly.

These are handy when you want to clean up generated files, backup files

Optional modules  clean clobber

special file lists 

add lists of files to be deleted to these global file lists

In build scripts you are generating files, final pdf files or whatever with a lot of intermediate files

Sometimes you want to rebuild everthing and wipe everything out old information and to get a brand new build of something

You need a way to delete all the files that were generated while keeping the source files that are needed.
You could manually write Rake tasks yourself to solve this but both CLEAN and CLOBBER solves this for you without reinventing the wheel.
Easy for these lists to get out of date when you solve this manually.

CLEAN and CLOBBER give you a central place
run rake clean and it removes every sigle file in that list
run rake clobber

HTML files are intermediate files. The pdf files are the final target files, your deliverable.
Typically you would add the HTML file to the CLEAN list and the pdf file to the CLOBBER list

CLEAN leaves the final files around but gets rid of all the intermediate files
CLOBBER get rid of everthing that was generated and leave project source files around







## Clean

require 'rake/clean' library


When is a good time to clean??
Before you build your Gem
You don’t want any of the intermediate files.

Intermediate files
clean them up because we don’t need them

``` ruby

CLEAN.include(SOMEFILELIST, 'thumbs')

```

## Clobber

?? Clean is a prerequisite to clobber?

When is a good time to clobber??

``` ruby

CLOBBER.include(SOMEFILELIST, 'finalthumbs')

```

?? require 'rake/clean'

~~~Should return project to a pristine state
Gets rid of intermediate files and final generated files

## Rake Dos & No-Nos

Rake is smart about doing the minimal amount possible. So should you then

Rake at its essence, is a task, break it down to its component pieces and specify what needs to be done in order to bigger tasks.

Don’t forget to create smart dependencies

Getting dependecies right and declaring them right is the most important step in Rake

Break up your Rakefile into component pieces. Rails makes this very easy for you if you make use of tasks/lib. Or make a directory called `rakelib` and build your Rake components in there. Rake loads the Rakefile and rakelib/*.rake files automatically.

Use namespaces for potentially conflcting task names.
especially if you have Rakefiles that are coming from different sources

task :go_to_store

namespace :apple do
  task :go_to_store

For file manipulations, make use of FileUtils and stay away from shell file manipulations. It’s a bit dirty when Rake makes them directly available to you.
You can set a verbose: false flag to avoid having all this output in the shell

You can run ruby commands wihtin Rake files

task :some_task do
  ruby 'ruby_program.rb'
end

Use rules if you have a lot of files instead of dynamically generated tasks

` rake -P` will list all of them btw. With tons of file tasks, this list becomes stupid long. Above all, it is lacking elegance that way. You haven’t reduced the patten to its core yet. Most importantly, this will make reuse easier while being DRY of course.

Collecting files for your tasks is not complicated in Rake. Instead of defining collections fo files yourself—and also updating this list—we let Rake be in charge of that. 


## Tips

User --dry-run
See thte log what they are doing. Just do the logging without the file operations
show you all the file operations it would do but actually don’t do them

Make use of Ruby methods for more complex stuff
encapsulation and proper OOP

rake -T buy

search rake tasks with buy
matches the name and not the description

rake -W boil_water
where is task defined
only with documented tasks??

## Final Thoughts


Rake is a task execution engine

I’ll leave you with a nice [video](http://www.infoq.com/interviews/jim-weirich-discusses-rake) interview where Jim Weirich discusses Rake.
