---
layout: post
title: Bourbon Neat-Mixins 02
date: 2015-09-22 04:29:10 +0100
comments: true
sharing: true
published: true 
categories: [ Sass,  Bourbon, Neat, Thoughtbot, SCSS, CSS, Design ]
---

{% img /images/Neat_01/Neat-pour.jpg %}

[{% img /images/bourbon-neat/Bourbon-Neat-Logo.png  250 450 %}](http://neat.bourbon.io/)

Now that you should have the basics under your belt, in the second article about Neat mixins I’ll dive a little deeper and explore the following function and mixins:

#### Function

+ new-breakpoint

#### Mixins

+ reset-layout-direction
+ direction-context
+ display-context
+ reset-display
+ fill-parent
+ reset-all
+ media
+ row


+ ### media

I assume you haven’t lived under a rock for the past couple of years and that you know about the importance of flexible designs that respond to the ever evolving landscape of screen sizes and types of devices. Bourbon Neat has your back and provides you with an elegant approach to manage these queries for your grids. Through the use of clever targeted media queries, your layout can be adapted to a wide range of devices without changing the content. Responsive design is here to stay and a responsible and sustainable use of media queries is king.

Something to avoid is what you could call query spagetthi—which basically is a tangled mess of media queries that becomes tricky to maintain lightening fast. So whatever you can do to keep these things neat and clean you should pay extra attention to I think. 

This mixin is no perfect antidote but definitly encourages a DRY approach to dealing with media queries—especially when paired with the **new-breakpoint** function. How so?

You can write media query blocks that can take grid contexts. Say you have two elements that add up to **12** columns. They span **3** and **9** columns respectively on desktop size screens which allow for **1088px** wide outer containers. For smaller devices / viewport sizes, just let the media query know at what size the context of **12** columns needs to change and adjust the size for the responsive elements accordingly. Boom!

Haml:
```haml
.container
  %aside 3 columns / 1 column
  %article 9 columns / 2 columns
```

Sass:
```sass
body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
aside
  +span-columns(3)
  background-color: LightSkyBlue 
  +media(max-width 700px, 4)
    +span-columns(1)

article
  +span-columns(9)
  background-color: Olive
  +media(max-width 700px, 4)
    +span-columns(2)
```

Screenshot without media query:

{% img /images/Neat_02/without-media-query.png %}

Screenshot with media query at 700px viewport size and 4 columns as grid context:

{% img /images/Neat_02/with-media-query.png %}

[codepen example](http://codepen.io/vis-kid/pen/wKzJXM)


I just provided the **media** mixin with a [media feature](http://www.w3.org/TR/css3-mediaqueries/#media1) via **max-width 700px** and a new grid context of **4** columns for the **$total-columns** **max-width** of the element. Having established a new grid context for both the **aside** and **article** elements for the viewport size of **700px** max, I only needed to tell the elements how many columns they can now span within the new total of **4** columns.  I think this is pretty darn readable and easy to organize. It get’s even cooler once you reuse *media contexts* ( media query / grid context ) via the **new-breakpoint** function and save them to a Sass variable . 

#### Attention!
If you provide this mixin with only a pixel value without any specific media feature

Sass:
```sass
.some-responsive-element
  +span-columns(8)
  +media(700px)
    +span-columns(4)
```

then Neat is going to use **$default-feature** which is **min-width**. Also, providing a grid context is optional and defaults to whatever is set through **$total-columns** in your **_grid-settings** partial. 

+ ### new-breakpoint

I’d say this handy custom Sass function is the Robin to your **media** Batman. If you want to make things a lot more readable and reuseable with your media queries, I don’t see a good reason why you won’t be using this sidekick to fight media query crime. 

Put simply, all it does is save media contexts ( media query / grid context ) through variables and gives you the opportunity to reuse them at your will in all your **media** mixins. In my book, that’s one hell of a useful extraction. Let’s take a look.

Sass:
``` sass
$tablet: new-breakpoint(min-width 768px max-width 1024px 4)

.some-responsive-element
  +span-columns(3)
  + media($tablet)
    + span-columns(1)

.some-other-responsive-element
  +span-columns(9)
  + media($tablet)
    + span-columns(2)
```

[codepen example](http://codepen.io/vis-kid/pen/merKVe)

To be extra sure we’re on the same page: You just provide all the media features you need—but no commas, colons, **or**, **and**—plus the number of columns for the new grid context and save it to a Sass variable. All that is left to do is feed your **media** mixins with the appropriate variable and DRY they are. 

I hope you’ll appreciate how clean this reads and how easy it is to tweak your layouts for various breakpoints—all in one central place. Gone are the days where managing tons of media queries quickly could get you in a fantasy fist fight with your former self. 


By using media queries, presentations can be tailored to a specific range of output devices without changing the content itself.

A media query is a logical expression that is either true or false. A media query is true if the media type of the media query matches the media type of the device where the user agent is running (as defined in the "Applies to" line), and all expressions in the media query are true.o

Several media queries can be combined in a media query list. A comma-separated list of media queries. If one or more of the media queries in the comma-separated list are true, the whole list is true, and otherwise false. In the media queries syntax, the comma expresses a logical OR, while the ‘and’ keyword expresses a logical AND.

If a media feature does not apply to the device where the UA is running, expressions involving the media feature will be false.o

Syntactically, media features resemble CSS properties: they have names and accept certain values. There are, however, several important differences between properties and media features:

Properties are used in declarations to give information about how to present a document. Media features are used in expressions to describe requirements of the output device.
Most media features accept optional ‘min-’ or ‘max-’ prefixes to express "greater or equal to" and "smaller or equal to" constraints. This syntax is used to avoid "<" and ">" characters which may conflict with HTML and XML. Those media features that accept prefixes will most often be used with prefixes, but can also be used alone.
Properties always require a value to form a declaration. Media features, on the other hand, can also be used without a value. For a media feature feature, (feature) will evaluate to true if (feature:x) will evaluate to true for a value x other than zero or zero followed by a unit identifier (i.e., other than 0, 0px, 0em, etc.). Media features that are prefixed by min/max cannot be used without a value. When a media feature prefixed with min/max is used without a value it makes the media query malformed.
Properties may accept more complex values, e.g., calculations that involve several other values. Media features only accept single values: one keyword, one number, or a number with a unit identifier. (The only exceptions are the ‘aspect-ratio’ and ‘device-aspect-ratio’ media features.)

The ‘orientation’ media feature is ‘portrait’ when the value of the ‘height’ media feature is greater than or equal to the value of the ‘width’ media feature. Otherwise ‘orientation’ is ‘landscape’.

The ‘resolution’ media feature describes the resolution of the output device, i.e. the density of the pixels. When querying devices with non-square pixels, in ‘min-resolution’ queries the least-dense dimension must be compared to the specified value and in ‘max-resolution’ queries the most-dense dimensions must be compared instead. A ‘resolution’ (without a "min-" or "max-" prefix) query never matches a device with non-square pixels.

+ ### new-breakpoint

So you’re probably thinking about what’s up with the DRY approach I mentioned a couple of paragraphs earlier right? That’s where this little beauty comes in.
