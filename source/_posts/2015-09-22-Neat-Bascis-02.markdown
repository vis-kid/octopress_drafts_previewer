---
layout: post
title: Bourbon Neat-Mixins 02
date: 2015-09-22 04:29:10 +0100
comments: true
sharing: true
published: true 
categories: [ Sass,  Bourbon, Neat, Thoughtbot, SCSS, CSS, Design ]
---

{% img /images/Neat_01/Neat-pour.jpg %}

[{% img /images/bourbon-neat/Bourbon-Neat-Logo.png  250 450 %}](http://neat.bourbon.io/)

Now that you should have the basics under your belt, in the second article about Neat mixins I’ll dive a little deeper and explore the following function and mixins:

#### Function

+ new-breakpoint

#### Mixins

+ reset-layout-direction
+ direction-context
+ display-context
+ reset-display
+ fill-parent
+ reset-all
+ media
+ row


+ ### media

I assume you haven’t lived under a rock for the past couple of years and that you know about the importance of flexible designs that respond to the ever evolving landscape of screen sizes and types of devices. Bourbon Neat has your back and provides you with an elegant approach to manage media queries for your grids. Through the use of clever targeted media queries, your layout can be adapted to a wide range of devices without making a mess. Responsive design is here to stay and a responsible and sustainable use of media queries is king.

Something to avoid is what you could call query spagetthi—which basically is a tangled mess of media queries that becomes tricky to maintain lightening fast. So whatever you can do to keep these things neat and clean you should pay extra attention to I think. This mixin is no perfect antidote but definitly encourages a DRY approach to dealing with media queries sanely—especially when paired with the **new-breakpoint** function. How so?

You can write media query blocks that can take grid contexts. Say you have two elements that add up to **12** columns—as defined in **$total-columns** in your **_grid-settings** file. These elements span **3** and **9** columns respectively on desktop size screens which allow for **1088px** wide outer containers. For smaller devices / viewport sizes, just let the **media** (query) mixin know at what size the context of **12** columns overall needs to change to another number and adjust the size for the responsive elements within that new context accordingly. Boom!

Haml:
```haml
.container
  %aside 3 columns / 1 column
  %article 9 columns / 2 columns
```

Sass:
```sass
body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
aside
  +span-columns(3)
  background-color: LightSkyBlue 
  +media(max-width 700px, 4)
    +span-columns(1)

article
  +span-columns(9)
  background-color: Olive
  +media(max-width 700px, 4)
    +span-columns(2)
```

Screenshot without media query:

{% img /images/Neat_02/without-media-query.png %}

Screenshot with media query at 700px viewport size and 4 columns as grid context:

{% img /images/Neat_02/with-media-query.png %}

[codepen example](http://codepen.io/vis-kid/pen/wKzJXM)


I just provided the **media** mixin with a [media feature](http://www.w3.org/TR/css3-mediaqueries/#media1) via **max-width 700px** and a new grid context of **4** columns for the **$total-columns** **max-width** of the element. Having established a new grid context for both the **aside** and **article** elements for the viewport size of **700px** max, I only needed to tell the elements how many columns they can now span within the new total of **4** columns.  I think this is pretty darn readable and easy to organize. It get’s even cooler once you reuse *media contexts* ( media query / grid context ) via the **new-breakpoint** function and save them to a Sass variable . 

#### Attention!
If you provide this mixin with only a pixel value without any specific media feature

Sass:
```sass
.some-responsive-element
  +span-columns(8)
  +media(700px)
    +span-columns(4)
```

then Neat is going to use **$default-feature** which is **min-width**. Also, providing a grid context is optional and defaults to whatever is set through **$total-columns** in your **_grid-settings** partial. 

+ ### new-breakpoint

So you’re probably thinking about what’s up with the DRY approach I mentioned a couple of paragraphs earlier right? That’s the spirit!

I’d say this handy custom Sass function is the Robin to your **media** Batman and keeps you from repeating yourself over and over. If you want to make things a lot more readable and reuseable with your media queries, I don’t see a good reason why you won’t be using this sidekick to fight media query crime. 

Put simply, all it does is save media contexts ( media query / grid context ) through variables and gives you the opportunity to reuse them at will in all your **media** mixins. In my book, that’s one hell of a useful extraction. Super readable too! Let’s take a look.

Sass:
``` sass
$tablet: new-breakpoint(min-width 768px max-width 1024px 4)

.some-responsive-element
  +span-columns(3)
  +media($tablet)
    +span-columns(1)

.some-other-responsive-element
  +span-columns(9)
  +media($tablet)
    +span-columns(2)
```

[codepen example](http://codepen.io/vis-kid/pen/merKVe)

To be extra sure we’re on the same page: You just provide all the media features you need—but no commas, colons, **or**, **and**—plus the number of columns for the new grid context and save it to a Sass variable. All that is left to do is feed your **media** mixins with the appropriate variable and DRY they are. 

I hope you’ll appreciate how clean this reads and how easy it is to tweak your layouts for various breakpoints—all in one central place. Gone are the days where managing tons of layout related media queries could quickly get you in a fantasy fist fight with your former self. 

+ ### fill-parent

This mixin is nothing fancy but might come in handy when you deal with media queries. If you want some element to quickly fill its parent by spanning the same number of columns, you got an easy solution. You don’t have to provide any arguments as well. Let’s look at a couple of screenshots for comparison:

Screenshot without **fill-parent**:

{% img /images/Neat_02/without-fill-parent.png%}

Screenshot with only one element that uses **fill-parent**:

{% img /images/Neat_02/single-fill-parent.png%}

Screenshot with both elements using **fill-parent**:

{% img /images/Neat_02/both-fill-parent.png%}

[codepen example](http://codepen.io/vis-kid/pen/Kdgebx)

Just wanted to show you that elements using **fill-parent** ignore other elements in the same row and aim to span the full width of its parent without considering its neighbors. I guess this one is straightforward enough, let’s move on!

+ ### direction-context

Every element in your Neat grid has a default **$layout-direction** which is set to **LTR** (left-to-right) in **settings/_grid.scss**. This simply means that behind the scenes, Neat is always using a **direction-context** of **left-to-right**. It is an obivious decision of course since most cultures are used to digest content from left to right.

Under the hood, this mixin does nothing else than changing the float direction of the applied element. What is neat is that within some directional context, let’s say left-to-right, you can gather a bunch of grid elements and change their direction to right-to-left all at once. Again, this solution makes things mostly more compact and readable for yourself as well as easier to understand / navigate for someone who’s not that familiar with a certain project.

Haml:
``` haml
.container
  %aside 3 columns
	%article 9 columns
```

Sass:
``` sass
body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
+direction-context(right-to-left)
  aside
    +span-columns(3)
    background-color: LightSkyBlue 

  article
    +span-columns(9)
    background-color: Olive
```

Screenshot “without” **direction-context**:

{% img /images/Neat_02/without-direction-context.png %}

Screenshot with **direction-context(right-to-left)**:

{% img /images/Neat_02/with-direction-context.png %}


[codepen example](http://codepen.io/vis-kid/pen/OyRKPq)

Just for the fun of it, here’s another example. Nothing new here for now—just the columns are of equal size now and also flow from **right-to-left**. 

Haml:
``` haml
.container
  %aside 3 columns
  %article 3 columns
```

Sass:
``` sass
@import "bourbon"
@import "neat" 

body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
+direction-context(right-to-left)
  aside
    +span-columns(3)
    background-color: LightSkyBlue 

  article
    +span-columns(3)
    background-color: Olive
```
Screenshot:

{% img /images/Neat_02/3-column-elements-with-direction-context-rtl.png %}

[codepen example](http://codepen.io/vis-kid/pen/ZbpgWp)

The following little tweak only has one of these 3-column elements use the mixin and therefore both float on the opposite side of the container. Nothing too magic, but might be handy to have in your bag of tricks. Et voilà! 

Sass:
``` sass
@import "bourbon"
@import "neat" 

body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
aside
  +span-columns(3)
  background-color: LightSkyBlue 
  
+direction-context(right-to-left)
  article
    +span-columns(3)
    background-color: Olive
```

{% img /images/Neat_02/one-3-column-element-with-direction-context-rtl.png %}
[codepen example](http://codepen.io/vis-kid/pen/yYamVJ)
