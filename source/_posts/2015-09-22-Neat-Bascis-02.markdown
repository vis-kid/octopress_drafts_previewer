---
layout: post
title: Bourbon Neat-Mixins 02
date: 2015-09-22 04:29:10 +0100
comments: true
sharing: true
published: true 
categories: [ Sass,  Bourbon, Neat, Thoughtbot, SCSS, CSS, Design ]
---

{% img /images/Neat_01/Neat-pour.jpg %}

[{% img /images/bourbon-neat/Bourbon-Neat-Logo.png  250 450 %}](http://neat.bourbon.io/)

Now that you should have the basics under your belt, in the second article about Neat mixins I’ll dive a little deeper and explore the following function and mixins:

#### Function

+ new-breakpoint

#### Mixins

+ reset-layout-direction
+ direction-context
+ display-context
+ reset-display
+ fill-parent
+ reset-all
+ media
+ row


+ ### media

I assume you haven’t lived under a rock for the past couple of years and that you know about the importance of flexible designs that respond to the ever evolving landscape of screen sizes and types of devices. Bourbon Neat has your back and provides you with an elegant approach to manage these queries for your grids. Through the use of clever targeted media queries, your layout can be adapted to a wide range of devices without changing the content. Responsive design is here to stay and a responsible and sustainable use of media queries is king.

Something to avoid is what you could call query spagetthi—which basically is a tangled mess of media queries that becomes tricky to maintain lightening fast. So whatever you can do to keep these things neat and clean you should pay extra attention to I think. 

This mixin is no perfect antidote but definitly encourages a DRY approach to dealing with media queries—especially when paired with the **new-breakpoint** function. How so?

You can write media query blocks that can take grid contexts. Say you have two elements that add up to **12** columns. They span **3** and **9** columns respectively on desktop size screens which allow for **1088px** wide outer containers. For smaller devices / viewport sizes, just let the media query know at what size the context of **12** columns needs to change and adjust the size for the responsive elements accordingly. Boom!

Haml:
```haml
.container
  %aside 3 columns / 1 column
  %article 9 columns / 2 columns
```

Sass:
```sass
body
  color: white
  background-color: white
  
.container
  +outer-container
  margin-top: 10px
  background-color: tomato

aside, article
  margin-bottom: 5px
  height: 200px  
  
aside
  +span-columns(3)
  background-color: LightSkyBlue 
  +media(max-width 700px, 4)
    +span-columns(1)

article
  +span-columns(9)
  background-color: Olive
  +media(max-width 700px, 4)
    +span-columns(2)
```

Screenshot without media query:

{% img /images/Neat_02/without-media-query.png %}

Screenshot with media query at 700px viewport size and 4 columns as grid context:

{% img /images/Neat_02/with-media-query.png %}

[codepen example](http://codepen.io/vis-kid/pen/wKzJXM)


I just provided the **media** mixin with a [media feature](http://www.w3.org/TR/css3-mediaqueries/#media1) via **max-width 700px** and a new grid context of **4** columns for the **$total-columns** **max-width** of the element. Having established a new grid context for both the **aside** and **article** elements for the viewport size of **700px** max, I only needed to tell the elements how many columns they can now span within the new total of **4** columns.  I think this is pretty darn readable and easy to organize. It get’s even cooler once you reuse *media contexts* ( media query / grid context ) via the **new-breakpoint** function and save them to a Sass variable . 

#### Attention!
If you provide this mixin with only a pixel value without any specific media feature

Sass:
```sass
.some-responsive-element
  +span-columns(8)
  +media(700px)
    +span-columns(4)
```

then Neat is going to use **$default-feature** which is **min-width**. Also, providing a grid context is optional and defaults to whatever is set through **$total-columns** in your **_grid-settings** partial. 

+ ### new-breakpoint

So you’re probably thinking about what’s up with the DRY approach I mentioned a couple of paragraphs earlier right? That’s the spirit!

I’d say this handy custom Sass function is the Robin to your **media** Batman and keeps you from repeating yourself over and over. If you want to make things a lot more readable and reuseable with your media queries, I don’t see a good reason why you won’t be using this sidekick to fight media query crime. 

Put simply, all it does is save media contexts ( media query / grid context ) through variables and gives you the opportunity to reuse them at your will in all your **media** mixins. In my book, that’s one hell of a useful extraction. Let’s take a look.

Sass:
``` sass
$tablet: new-breakpoint(min-width 768px max-width 1024px 4)

.some-responsive-element
  +span-columns(3)
  + media($tablet)
    + span-columns(1)

.some-other-responsive-element
  +span-columns(9)
  + media($tablet)
    + span-columns(2)
```

[codepen example](http://codepen.io/vis-kid/pen/merKVe)

To be extra sure we’re on the same page: You just provide all the media features you need—but no commas, colons, **or**, **and**—plus the number of columns for the new grid context and save it to a Sass variable. All that is left to do is feed your **media** mixins with the appropriate variable and DRY they are. 

I hope you’ll appreciate how clean this reads and how easy it is to tweak your layouts for various breakpoints—all in one central place. Gone are the days where managing tons of media queries quickly could get you in a fantasy fist fight with your former self. 

+ ### fill-parent

This mixin is nothing fancy but might come in handy when you deal with media queries. If you want some element to quickly fill its parent by spanning the same number of columns, you got an easy solution. You don’t have to provide any arguments as well. Let’s look at a couple of screenshots for comparison:

Screenshot without **fill-parent**:

{% img /images/Neat_02/without-fill-parent.png%}

Screenshot with only one element that uses **fill-parent**:

{% img /images/Neat_02/single-fill-parent.png%}

Screenshot with both elements using **fill-parent**:

{% img /images/Neat_02/both-fill-parent.png%}

[codepen example](http://codepen.io/vis-kid/pen/Kdgebx)

Just wanted to show you that it ignores other elements in the same row and aims to span the full width of its parent without considering its neighbors. I guess this one is straightforward enough, let’s move on!
